/*
 * handles button events and triggers.
 *
 * Copyright (C) 2014-2015 Texas Instruments Incorporated - http://www.ti.com/
 * ALL RIGHTS RESERVED
 *
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <xdc/cfg/global.h>
#include <ti/sysbios/knl/Swi.h>

#include <inc/hw_memmap.h>
#include <inc/hw_types.h>
#include <inc/tm4c129xnczad.h>
#include "inc/hw_hibernate.h"

#include <driverlib/rom.h>
#include <driverlib/rom_map.h>
#include <driverlib/pin_map.h>
#include <driverlib/sysctl.h>
#include <driverlib/gpio.h>
#include <driverlib/epi.h>

#include <driverlib/timer.h>
#include <time.h>
#include <driverlib/hibernate.h>
#include <xdc/runtime/Types.h>
#include <xdc/runtime/System.h>

#include "common.h"
#include "GPIO Mapping.h"
#include "scan.h"
#include "NIRscanNano.h"
#include "led.h"
#include "nano_timer.h"
#include "button.h"
#ifdef NIRSCAN_INCLUDE_BLE
#include "BLECommonDefs.h"
#include "BLENotificationHandler.h"
#endif
static bool scanButtonLocked = false;
#ifdef NIRSCAN_INCLUDE_BLE
extern bool BLEStatus;
#endif

uint8_t		g_TestOnOffButtonPresses = 0;			// Number of consecutive button presses
uint8_t		g_TestScanButtonPresses = 0;
uint8_t		g_ButtonTestMode = 0;				// Button Test Mode
bool b_sleeping = false;

/**
 *
 * Handles logic activated by pressing the scan button on the TIVA EVM
 * specifically, initiate a scan, and debounce the button
 * This handler get called upon press as well as upon release of the button
 * A long press on this button ( > 3 sec) is treated as BT ON/OFF instead of scan.
 *
 */
void HandleScanButtonInterrupt()
{
    int  num_ticks;
    static int count1, count2;
    static bool button_depressed = false;
#ifdef NIRSCAN_INCLUDE_BLE
	uint32_t scan_time = 0;
	uint8_t notification[sizeof(uint32_t) + 1];
#endif

#ifdef SCAN_BUTTON_EXP_CONN
	if ( SCAN_RIS && SCAN_GPIO_MASK ) {
#endif

		SCAN_ICR |= SCAN_GPIO_MASK; // clear interrupt generated by Scan button
	
		// Register activity so that inactivity monitor knows about it
		nano_timer_increment_activity_count();

		// do not allow interruption of a scan in progress
		if ( g_ButtonTestMode )
		{
			g_TestScanButtonPresses++;
		}
		else if (IsScanButtonLocked() == false)
		{
			if(button_depressed == false)
			{
				//this interrupt was caused by button press
				count1 = nano_timer_get_tick();
				button_depressed = true;
				return;
			}
			else
			{
				//this interrupt was caused by button release
				button_depressed = false;
				count2 = nano_timer_get_tick();
			}

			LockScanButton();       // indicates scan in progress
			if(count2 >= count1)
			{
				num_ticks = count2 - count1;
			}
			else
			{
				//nano_timer_count has rolled over; so total count is sum of count before rollover and count after
				num_ticks = NANO_TIMER_TICKS_PER_MIN*MAX_TIME_BEFORE_HIBERNATION_MINS - count1 + count2;
			}

	#ifdef NIRSCAN_INCLUDE_BLE
			if ( num_ticks >= 3*NANO_TIMER_TICKS_PER_SEC )
			{   // 3 seconds, so it must be bluetooth enable
				if ( !BLEStatus )
				{
					Semaphore_post( BLEStartSem );
					BLEStatus = true;
				}
				else
				{
					Semaphore_post( BLEEndSem );
					BLEStatus = false;
				}
				UnlockScanButton();
			}
			else
			{
	#else
			if (num_ticks != 0);
	#endif
				Scan_StoreToSDcard();
				Semaphore_post( scanSem );    // To initiate scan
	#ifdef NIRSCAN_INCLUDE_BLE
				if (true == BLEStatus)
				{
					notification[0] = 0x01;

					scan_time = Scan_ComputeScanTime();
					memcpy(&notification[1],&scan_time,sizeof(uint32_t));

					if (0 == bleNotificationHandler_setNotificationData(BLE_NOTIFY_SCAN_STATUS, 5, &notification[0]))
						Semaphore_post(BLENotifySem);
				}
			}
	#endif
		}
#ifdef SCAN_BUTTON_EXP_CONN
	}
#endif
}

/**
 * Function to be used in order to ignore multiple presses on scan button
 * until the current event handling is not complete.
 *
 */
void UnlockScanButton()
{
	scanButtonLocked = false;
}

/**
 * Function to be used in order to ignore multiple presses on scan button
 * until the current event handling is not complete.
 *
 */
void LockScanButton()
{
	scanButtonLocked = true;
}

/**
 * Returns status of whether scan button press event is locked/unlocked
 * this lock is released after button press event handling is complete.
 *
 */
bool IsScanButtonLocked()
{
	return scanButtonLocked;
}

/**
 * Handles logic activated by pressing WAKE button to wake up system from hibernation
 *
 */
void HibernateHandler(void)
{
	volatile uint32_t ui32Status;
	struct tm prevTime;
	
	ui32Status = MAP_HibernateIntStatus( true );	// Get the interrupt status and clear any pending interrupts.
	MAP_HibernateIntClear( ui32Status );

	if ( ui32Status & HIBERNATE_INT_PIN_WAKE )
	{		// Was the Wake pin that caused the interrupt?
		if(b_sleeping == true)
		{
			NIRscanNano_powerUp();
			g_TestOnOffButtonPresses++;
			nano_timer_reset_activity_count();	// Reset activity count that monitors inactivity and hibernates
			nano_hibernate_calendar_get(&prevTime);
			b_sleeping = false;
		}
	}
} 


